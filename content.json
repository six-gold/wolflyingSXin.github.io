[{"title":"Java Collection","date":"2017-10-22T14:05:26.000Z","path":"2017/10/22/Java-Collection/","text":"CollectionsThe collections framework is a unified architecture for representing and manipulating collections, enabling them to be manipulated independently of the details of their representation. It reduces programming effort while increasing performance. It enables interoperability among unrelated APIs, reduces effort in designing and learning new APIs, and fosters software reuse. The framework is based on more than a dozen collection interfaces. It includes implementations of these interfaces and algorithms to manipulate them. Collection interfaces hierarchy Collection Set (interface) SortedSet (interface) NavigableSet (interface) extends SortedSet List (interface) Queue (interface) Deque (interface) Map (interface) SortedMap (interface) Abstract Class AbstractCollection implements Collection AbstractList extends AbstractCollection implements List AbstractSequentialList extends AbstractList AbstractSet extends AbstractCollection implements Set AbstractMap implements Map AbstractQueue extends AbstractCollection implements Queue Collections Implements Collection Set HashSet extends AbstractSet implements Set backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set. This class permits the null element. LinkedHashSet extends HashSet implements Set Hash table and linked list implements of the Set interface, with predictable iteration order. map =&gt; LinkedHashMap TreeSet extends AbstractSet implements NavigableSet A NavigableSet implemention based on a TreeMap List AbstractList extends AbstractCollection implements List ArrayList extends AbstractList implements List permits all elements, including null LinkedList extends AbstractSequentialList implements List Doubly-linked list implemention of List and Deque interface. Vector extends AbstractList implements List synchronized Queue Deque Map SortedMap (interface) NavigableMap extends SortedMap (interface) TreeMap extends AbstractMap implements NavigableMap A Red-Black tree based NavigableMap implements. HashMap extends AbstractMap implements Map permits null values and null* key LinkedHashMap extends HashMap implements Map A special LinkedHashMap(int,float,boolean) constructor is provided to create a linked hash map whose order of iteration is the order in which its entries were last accessed. HashTable extends Dictionary implements Map Any non-null object can be used as a key or as a value","excerpt":"CollectionsThe collections framework is a unified architecture for representing and manipulating collections, enabling them to be manipulated independently of the details of their representation. It reduces programming effort while increasing performance. It enables interoperability among unrelated APIs, reduces effort in designing and learning new APIs, and fosters software reuse. The framework is based on more than a dozen collection interfaces. It includes implementations of these interfaces and algorithms to manipulate them.","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java IO","date":"2017-10-13T06:20:42.000Z","path":"2017/10/13/Java-IO/","text":"Basic I/OI/O StreamsByte StreamsPrograms use byte streams to perform input and output of 8-bit bytes. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class CopyBytes &#123; public static void main(String[] args) &#123; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream(\"xanadu.txt\"); out = new FileOutputStream(\"outagain.txt\"); int c; while ((c = in.read()) ! = -1) &#123; out.write(c); &#125; &#125; finally &#123; if (in != null) &#123; in.close(); &#125; if (out != null) &#123; out.close(); &#125; &#125; &#125;&#125; Byte streams should only be used for the most primitive I/O. All other stream types are built on byte streams. Character StreamsThe Java platform stores character values using Unicode conventions. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class CopyCharacters &#123; public static void main(String[] args) throws IOException &#123; FileReader inputStream = null; FileWriter outputStream = null; try &#123; inputStream = new FileReader(\"xanadu.txt\"); outputStream = new FileWriter(\"characteroutput.txt\"); int c; while ((c = inputStream.read()) != -1) &#123; outputStream.write(c); &#125; &#125; finally &#123; if (inputStream != null) &#123; inputStream.close(); &#125; if (outputStream != null) &#123; outputStream.close(); &#125; &#125; &#125;&#125; In CopyCharacters, the int variable holds a character value in its last 16 bits; in CopyBytes, the int variable holds a byte value in its last 8 bits. Line-Oriented I/O 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.FileReader;import java.io.FileWriter;import java.io.BufferedReader;import java.io.PrintWriter;import java.io.IOException;public class CopyLines &#123; public static void main(String[] args) throws IOException &#123; BufferedReader inputStream = null; PrintWriter outputStream = null; try &#123; inputStream = new BufferedReader(new FileReader(\"xanadu.txt\")); outputStream = new PrintWriter(new FileWriter(\"characteroutput.txt\")); String l; while ((l = inputStream.readLine()) != null) &#123; outputStream.println(l); &#125; &#125; finally &#123; if (inputStream != null) &#123; inputStream.close(); &#125; if (outputStream != null) &#123; outputStream.close(); &#125; &#125; &#125;&#125; Buffered Streams BufferedInputStream and BufferedOutputStream create buffered byte Streams, BufferedReader and BufferedWriter create buffered character streams. To flush a stream manually, invoke its flush method. The flush method is valid on any output stream, but has no effect unless the stream is buffered. ScanningBy default, a scanner uses white space to separate tokens. (White space characters include blanks, tabs, and line terminators.) (java.lang.Character.isWhitespace) 123456789101112131415161718192021222324252627282930313233343536import java.io.*;import java.util.Scanner;public class ScanXan &#123; public static void main(String[] args) throws IOException &#123; Scanner s = null; try &#123; s = new Scanner(new BufferedReader(new FileReader(\"xanadu.txt\"))); while (s.hasNext()) &#123; System.out.println(s.next()); &#125; &#125; finally &#123; if (s != null) &#123; s.close(); &#125; &#125; &#125;&#125; A scanner is not a stream, you need to close it to indicate that you’re done with its underlying stream. To use a different token separator, invoke useDelimiter(), specifying a regular expression. 12s.useDelimiter(\",\\\\s*\"); Translating Individual tokensScanner also supports tokens for all of the Java language’s primitive types(except for char), as well as BigInteger and BigDecimal. Also, numeric values can use thousands separator. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.io.FileReader;import java.io.BufferedReader;import java.io.IOException;import java.util.Scanner;import java.util.Locale;public class ScanSum &#123; public static void main(String[] args) throws IOException &#123; Scanner s = null; double sum = 0; try &#123; s = new Scanner(new BufferedReader(new FileReader(\"usnumbers.txt\"))); s.useLocale(Locale.US); while (s.hasNext()) &#123; if (s.hasNextDouble()) &#123; sum += s.nextDouble(); &#125; else &#123; s.next(); &#125; &#125; &#125; finally &#123; if (s != null) &#123; s.close(); &#125; &#125; System.out.println(sum); &#125;&#125; FormattingStream objects that implement formatting are instances of either PrintWriter, a character stream class, or PrintStream, a byte stream class. I/O from Command LineStandard StreamsStandard Streams are byte streams, System.out and System.err are defined as PrintStream objects. PrintStream utilizes an internal character stream object to emulate many of the features of character streams. System.in is a byte stream with no character stream features. To use Standard Input as a character stream, wrap System.in in InputStreamReader. 12InputStreamReader cin = new InputStreamReader(System.in); The Console 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.io.Console;import java.util.Arrays;import java.io.IOException;public class Password &#123; public static void main(String[] args) throws IOException &#123; Console c = System.console(); if (c == null) &#123; System.err.println(\"No console.\") System.exit(1); &#125; String login = c.readLine(\"Enter you login: \"); char[] oldPassword = c.readPassword(\"Enter you old password: \"); if (verify(login, oldPassword)) &#123; boolean noMatch; do &#123; char[] newPassword1 = c.readPassword(\"Enter new password: \"); char[] newPassword2 = c.readPassword(\"Enter new password again: \"); noMatch = ! Arrays.equals(newPassword1, newPassword2); if (noMatch) &#123; c.format(\"Passwords don't match, Try again.%n\"); &#125; else &#123; change(login, newPassword1); c.format(\"Password for %s changed.%n\", login); &#125; Arrays.fill(newPassword1, ' '); Arrays.fill(newPassword2, ' '); &#125; while (noMatch); &#125; Arrays.fill(oldPassword, ' '); &#125; static boolean verify(String login, char[] password) &#123; // This method always returns true in this example. Modify this method to verify password according to your rules. return true; &#125; static void change(String login, char[] password) &#123; // Modify this method to change password according to your rules. &#125;&#125; Data StreamsData steams support binary I/O of primitive data type values (boolean, char, byte, short, int, long, float, and double) as well as String values. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.io.*;public class DataStreams &#123; static final String dataFile = \"invoicedata\"; static final double[] prices = &#123;19.99, 9.99, 15.99, 3.99, 4.99&#125;; static final int[] units = &#123; 12, 8, 13, 29, 50 &#125;; static final String[] descs = &#123; \"Java T-shirt\", \"Java Mug\", \"Duke Juggling Dolls\", \"Java Pin\", \"Java Key Chain\" &#125;; public static void main(String[] args) throws IOException &#123; DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(dataFile))); for (int i = 0; i &lt; prices.length; i++) &#123; out.writeDouble(prices[i]); out.writeInt(units[i]); out.writeUTF(descs[i]); &#125; out.close(); DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(dataFile))); double price; int unit; String desc; double total = 0.0; try &#123; while (true) &#123; price = in.readDouble(); unit = in.readInt(); desc = in.readUTF(); System.out.format(\"You ordered %d\" + \" units of %s at $%.2f%n\", unit, desc, price); total += unit * price; &#125; &#125; catch (EOFException e) &#123; &#125; finally &#123; in.close(); &#125; &#125;&#125; Notice that DataStreams detects an end-of-file condition by catching EOFException, instead of testing for an invalid return value. All implementations of DataInput methods use EOFException instead of return values. File I/OThe Patch class Creating a Path 123456Path p1 = Paths.get(\"/tmp/foo\");Path p2 = Paths.get(args[0]);Path p3 = Paths.get(URI.create(\"file:///Users/joe/FileTest.java\")); The Paths.get method is shorthand for the following code: 12Path p4 = FileSystems.getDefault().getPath(\"/users/sally\"); The following example creates /u/joe/logs/foo.log assuming your home directory is /u/joe, or C:\\joe\\logs\\foo.log if you are on Windows. 12Path p5 = Paths.get(System.getProperty(\"user.home\"), \"logs\", \"foo.log\"); Retrieving Infomation about a Path 123456789101112131415161718192021222324// Windows syntaxPath path = Paths.get(\"C:\\\\home\\\\joe\\\\foo\");// Solaris syntaxPath path = Paths.get(\"/home/joe/foo\");System.out.format(\"toString: %s%n\", path.toString());System.out.format(\"getFileName: %s%n\", path.getFileName());System.out.format(\"getName(0): %s%n\", path.getName(0));System.out.format(\"getNameCount: %d%n\", path.getNameCount());System.out.format(\"subpath(0,2): %s%n\", path.subpath(0, 2));System.out.format(\"getParent: %s%n\", path.getParent());System.out.format(\"getRoot: %s%n\", path.getRoot()); Removing Redundancies From a Path The normalize method removes any redundant elements, which includes any “.” or “directory/..” occurrences. normalize doesn’t check at the file system when it cleans up a path. It is a purely syntactic operation. To clean up a path while ensuring that the result locates the correct file, you can use the toRealPath method. Reading, Writing, and Creating FilesThe OpenOptions Parameter WRITE Opens the file for write access APPEND Appends the new data to the end of the file. This option is used with WRITE or CREATE options. TRUNCATE_EXISTING Truncates the file to zero bytes. This option is used with the WRITE option. CREATE_NEW Creates a new file and throws an exception if the file already exists. CREATE Opens the file if it exists or creates a new file if it does not. DELETE_ON_CLOSE Deletes the file when the stream is closed. This option is useful for temporary files. SPARSE Hints that a newly created file will be sparse. SYNC Keeps the file (both content and metadata) synchronized with the underlying storage device. DSYNC Keeps the file content synchronized with the underlying storage device. Commonly Used Methods for Small Files Reading All Bytes or Lines from a File 123456Path file = ...;byte[] fileArray;fileArray = Files.readAllBytes(file); Writing All Bytes or Lines to a File write(Path, byte[], OpenOpntion…) write(Path, Iterable, Charset, OpenOpntion) 123456Path file = ...;byte[] buf = ...;Files.write(file, buf); Buffered I/O Methods for Text FilesReading a File Using Buffered Stream I/O 1234567891011121314151617181920Charset charset = Charset.forName(\"US-ASCII\");try &#123; BufferedReader reader = Files.newBufferedReader(file, charset); String line = null; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125;&#125; catch (IOException x) &#123; System.err.format(\"IOException: %s%n\", x);&#125; Writing a File Using Buffered Stream I/O 1234567891011121314Charset charset = Charset.forName(\"US-ASCII\");String s = ...;try (BufferedWriter writer = Files.newBufferedWriter(file, charset);) &#123; writer.write(s, 0, s.length());&#125; catch (IOException x) &#123; System.err.format(\"IOException: %s%n\", x);&#125; Methods for Unbuffered Streams and Interoperable with java.io APISReading a File by Using Stream I/O 123456789101112131415161718Path file = ...;try (InputStream in = File.newInputStream(file);BufferedReader reader = new BufferedReader(new InputStreamReader(in));) &#123; String line = null; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125;&#125; catch (IOException e) &#123; System.err.println(e);&#125; Creating and Writing a File by Using Stream I/O 12345678910111213141516171819202122232425262728293031323334import static java.nio.file.StandardOpenOption.*;import java.nio.file.*;import java.io.*;public class LogFileTest &#123; public static void main(String[] args) &#123; String s = \"Hello World!\"; byte data[] = s.getBytes(); Path p = Paths.get(\"./logfile.txt\"); try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(p, CREATE, APPEND));) &#123; out.write(data, o, data.length); &#125; catch (IOException x) &#123; System.err.println(x); &#125; &#125;&#125; Methods for Channels and ByteBuffersReading and Writing Files by Using Channel I/OWhile steam I/O reads a character at a time, channel I/O reads a buffer at a time. 123456789101112131415161718192021222324// Defaults to READtry (SeekableByteChannel sbc = Files.newByteChannel(file);) &#123; ByteBuffer buf = ByteBuffer.allocate(10); String encoding = System.getProperty(\"file.encoding\"); while (sbc.read(buf) &gt; 0) &#123; buf.rewind(); System.out.print(Charset.forName(encoding).decode(buf)); buf.flip(); &#125;&#125; catch (IOException x) &#123; System.out.println(\"caught exception: \" + x);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import static java.nio.file.StandardOpenOption.*;import java.nio.*;import java.nio.channels.*;import java.nio.file.*;import java.nio.fle.attribute.*;import java.io.*;import java.util.*;public class LogFilePermissionsTest &#123; public static void main(String[] args) &#123; Set&lt;OpenOption&gt; options = new HashSet&lt;OpenOption&gt;(); options.add(APPEND); options.add(CREATE); Set&lt;PosixFilePermission&gt; perms = PosixFilePermission.fromString(\"rw-r-----\"); String s = \"Hello World!\"; byte data[] = s.getBytes(); ByteBuffer bb = ByteBuffer.wrap(data); Path file = Paths.get(\"./permissions.log\"); try (SeekableByteChannel sbc = Files.newByteChannel(file, options, attr);) &#123; sbc.write(bb); &#125; catch (IOException x) &#123; System.out.println(\"Exception thrown: \" + x); &#125; &#125;&#125; Methods for Creating Regular and Temporary FilesCreating FilesYou can create an empty file with an initial set of attributes by using the createFile(Path, FileAttribute&lt;?&gt;) method. If the file already exists, createFile throws an exception. 12345678910111213141516Path file = ...;try &#123; Files.createFile(file);&#125; catch (FileAlreadyExistsException x) &#123; System.err.format(\"file named %s already exists%n\", file);&#125; catch (IOException x) &#123; System.err.format(\"createFile error: %s%n\", x);&#125; Creating Temporary FilesYou can create a temporary file using one of the following createTempFile methods: createTempFile(Path, String, String, FileAttribute&lt;?&gt;) createTempFile(String, String, FileAttribute&lt;?&gt;) The first method allows the code to specify a directory for the temporary file and the second method creates a new file in the default temporary-file directory. 123456789101112try &#123; Path tempFile = Files.createTempFile(null, \".myapp\"); System.out.format(\"The temporary file has been created: %s%n\", tempFile);&#125; catch (IOException e) &#123; System.err.format(\"IOException: %s%n\", x);&#125; Random Access Files 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162String s = \"I was here!\\n\";byte data[] = s.getBytes();ByteBuffer out = ByteBuffer.wrap(data);ByteBuffer copy = ByteBuffer.allocate(12);try (FileChannel fc = (FileChannel.open(file, READ, WRITE));) &#123; int nread; do &#123; nread = fc.read(copy); &#125; while (nread != -1 &amp;&amp; copy.hasRemaining()); fc.position(0); while (out.hasRemaining()) &#123; fc.write(out); &#125; out.rewind(); long length = fc.size(); fc.position(length - 1); copy.flip(); while (copy.hasRemaining()) &#123; fc.write(out); &#125; while (out.hasRemaining()) &#123; fc.write(out); &#125;&#125; catch (IOException x) &#123; System.out.println(\"I/O Exception: \" + x);&#125; Creating and Reading DirectoriesListing a Directory’s Contents 12345678910111213141516Path dir = ...;try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir);) &#123; for (Path file: stream ) &#123; System.out.println(file.getFileName()); &#125;&#125; catch (IOException | DirectoryIteratorException x) &#123; System.err.println(x);&#125; If there is an exception during directory iteration then DirectoryIteratorException is thrown with IOException as the cause. Writing Your Own Directory Filter 12345678910DirectoryStream.Filter&lt;Path&gt; filter = new DirectoryStream.Filter&lt;Path&gt;() &#123; public boolean accept(Path file) throws IOException &#123; return Files.isDirectory(file); &#125;&#125;; Links, Symbolic or OtherwiseThe java.nio.file package, and the Path class in particular, is “link aware”. Hard links are more restrictive than symbolic links, as follows: The target of the link must exist Hard links are generally not allowed on directories. Hard links are not allowed to cross partitions or volumes. Therefore, they cannot exist across file systems. A hard link looks, and behaves, like a regular file, so they can be hard to find. A hard link is, for all intents and purposes, the same entity as the original file.They have the same file permissions, time stamps, and so on. Path methods work seamlessly with hard links. Walking the File TreeThe FileVisitor InterfaceTo walk a file tree, you first need to implement a FileVisitor. If you don’t need implement all four of the FileVisitor methods, instead of implementing the FileVisitor interface, you can extend the SimpleFileVisitor class. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import static java.nio.file.FileVisitResult.*;public static class PrintFiles extends SimpleFileVisitor&lt;Path&gt; &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attr) &#123; if (attr.isSymbolicLink()) &#123; System.out.format(\"Symbolic link: %s\", file); &#125; else if (attr.isRegularFile()) &#123; System.out.format(\"Regular file: %s\", file); &#125; else &#123; System.out.format(\"Other: %s\", file); &#125; System.out.println(\"(\" + attr.size() + \"bytes)\"); return CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) &#123; System.out.format(\"Directory: %s%n\", dir); return CONTINUE; &#125; @Override public FileVisitResult visitFileFailed(Path file, IOException exc) &#123; System.err.println(exc); return CONTINUE; &#125;&#125; There are two walkFileTree methods in the Files class: walkFileTree(Path, FileVisitor) walkFileTree(Path, Set&lt;FileVisitOption, int, FileVisitor) 123456Path startingDir = ...;PrintFiles pf = new PrintFiles();Files.walkFileTree(startingDir, pf); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import java.io.*;import java.nio.file.*;import java.nio.file.attribute.*;import static java.nio.file.FileVisitResult.*;import static java.nio.file.FileVisitOption.*;import java.util.*;public class Find &#123; public static class Finder extends SimpleFileVisitor&lt;Path&gt; &#123; private final PathMatcher mathcer; private int numMatches = 0; Finder(String pattern) &#123; match = FileSystems.getDefault().getPathMatcher(\"glob:\" + pattern); &#125; void find(Path file) &#123; Path name = file.getFileName(); if (name != null &amp;&amp; matcher.matches(name)) &#123; numMatches++; System.out.println(file); &#125; &#125; void done() &#123; System.out.println(\"Matched: \" + numMatches); &#125; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) &#123; find(file); return CONTINUE; &#125; @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) &#123; find(dir); return CONTINUE; &#125; @Override public FileVisitResult visitFileFailed(Path file, IOException exc) &#123; System.err.println(exc); return CONTINUE; &#125; &#125; static void useage() &#123; System.err.println(\"java Find &lt;path&gt;\" + \"-name \\\"&lt;glob_pattern&gt;\\\"\"); System.exit(-1); &#125; public static void main(String[] args) throws IOException &#123; if (args.length &lt; 3 || !args[1].equals(\"-name\")) &#123; useage() &#125; Path startingDir = Paths.get(args[0]); String pattern = args[2]; Finder finder = new Finder(pattern); Files.walkFileTree(startingDir, finder); finder.done(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480import java.nio.file.*;import java.nio.file.attribute.*;import static java.nio.file.attribute.PosixFilePermission.*;import static java.nio.file.FileVisitResult.*;import java.io.IOException;import java.util.*;public class Chmod &#123; public static Changer compile(String exprs) &#123; if (exprs.length() &lt; 2) &#123; throw new IllegalArgumentException(\"Invalid mode\"); &#125; final Set&lt;PosixFilePermission&gt; toAdd = new HashSet&lt;PosixFilePermission&gt;(); final Set&lt;PosixFilePermission&gt; toRemove = new HashSet&lt;PosixFilePermission&gt;(); for (String expr: exprs.split(\",\")) &#123; if (expr.length() &lt; 2) &#123; throw new IllegalArgumentException(\"Invalid mode\"); &#125; int pos = 0; boolean u = false; boolean g = false; boolean o = false; boolean done = false; for (; ; ) &#123; switch (expr.charAt(pos)) &#123; case 'u' : u = true; break; case 'g' : g = true; break; case 'o' : o = true; break; case 'a' : u = true; g = true; o = true; break; default : done = true; &#125; if (done) &#123; break; &#125; pos++; &#125; if (!u &amp;&amp; !g &amp;&amp; !o) &#123; throw new IllegalArgumentException(\"Invalid mode\"); &#125; char op = expr.charAt(pos++); String mask = (expr.length() == pos) ? \"\" : expr.substring(pos); boolean add = (op == '+'); boolean remove = (op == '-'); boolean assign = (op == '='); if (!add &amp;&amp; !remove &amp;&amp; !assign) throw new IllegalArgumentException(\"Invalid mode\"); if (assign &amp;&amp; mask.length() == 0) &#123; assign = false; remove = true; mask = \"rwx\"; &#125; boolean r = false; boolean w = false; boolean x = false; for (int i = 0; i &lt; mask.length(); i++) &#123; switch (mask.charAt(i)) &#123; case 'r' : r = true; break; case 'w' : w = true; break; case 'x' : x = true; break; default: throw new IllegalArgumentException(\"Invalid mode\"); &#125; &#125; if (add) &#123; if (u) &#123; if (r) toAdd.add(OWNER_READ); if (w) toAdd.add(OWNER_WRITE); if (x) toAdd.add(OWNER_EXECUTE); &#125; if (g) &#123; if (r) toAdd.add(GROUP_READ); if (w) toAdd.add(GROUP_WRITE); if (x) toAdd.add(GROUP_EXECUTE); &#125; if (o) &#123; if (r) toAdd.add(OTHERS_READ); if (w) toAdd.add(OTHERS_WRITE); if (x) toAdd.add(OTHERS_EXECUTE); &#125; &#125; if (remove) &#123; if (u) &#123; if (r) toRemove.add(OWNER_READ); if (w) toRemove.add(OWNER_WRITE); if (x) toRemove.add(OWNER_EXECUTE); &#125; if (g) &#123; if (r) toRemove.add(GROUP_READ); if (w) toRemove.add(GROUP_WRITE); if (x) toRemove.add(GROUP_EXECUTE); &#125; if (o) &#123; if (r) toRemove.add(OTHERS_READ); if (w) toRemove.add(OTHERS_WRITE); if (x) toRemove.add(OTHERS_EXECUTE); &#125; &#125; if (assign) &#123; if (u) &#123; if (r) toAdd.add(OWNER_READ); else toRemove.add(OWNER_READ); if (w) toAdd.add(OWNER_WRITE); else toRemove.add(OWNER_WRITE); if (x) toAdd.add(OWNER_EXECUTE); else toRemove.add(OWNER_EXECUTE); &#125; if (g) &#123; if (r) toAdd.add(GROUP_READ); else toRemove.add(GROUP_READ); if (w) toAdd.add(GROUP_WRITE); else toRemove.add(GROUP_WRITE); if (x) toAdd.add(GROUP_EXECUTE); else toRemove.add(GROUP_EXECUTE); &#125; if (o) &#123; if (r) toAdd.add(OTHERS_READ); else toRemove.add(OTHERS_READ); if (w) toAdd.add(OTHERS_WRITE); else toRemove.add(OTHERS_WRITE); if (x) toAdd.add(OTHERS_EXECUTE); else toRemove.add(OTHERS_EXECUTE); &#125; &#125; &#125; return new Changer() &#123; public Set&lt;PosixFilePermission&gt; change(Set&lt;PosixFilePermission&gt; perms) &#123; perms.addAll(toAdd); perms.removeAll(toRemove); return perms; &#125; &#125;; &#125; public interface Changer &#123; Set&lt;PosixFilePermission&gt; change(Set&lt;PosixFilePermission&gt; perms); &#125; static void chmod(Path file, Changer changer) &#123; try &#123; Set&lt;PosixFilePermission&gt; perms = Files.getPosixFilePermissions(file); Files.setPosixFilePermissions(file, changer.change(perms)); &#125; catch (IOException e) &#123; System.err.println(e); &#125; &#125; static class TreeVisitor implements FileVisitor&lt;Path&gt; &#123; private final Changer changer; TreeVisitor(Changer changer) &#123; this.changer = changer; &#125; @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) &#123; chmod(dir, changer); return CONTINUE; &#125; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) &#123; chmod(file, changer); return CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) &#123; if (exc != null) System.err.println(\"WARNING: \" + exc); return CONTINUE; &#125; @Override public FileVisitResult visitFileFailed(Path file, IOException exc) &#123; System.err.println(\"WARNING: \" + exc); return CONTINUE; &#125; &#125; static void usage() &#123; System.err.println(\"java Chmod [-R] symbolic-mode-list file...\"); System.exit(-1); &#125; public static void main(String[] args) throws IOException &#123; if (args.length &lt; 2) usage(); int argi = 0; int maxDepth = 0; if (args[argi].equals(\"-R\")) &#123; if (args.length &lt; 3) usage(); argi++; maxDepth = Integer.MAX_VALUE; &#125; Changer changer = compile(args[argi++]); TreeVisitor vistor = new TreeVisitor(changer); Set&lt;FileVisitOption&gt; opts = Collections.emptySet(); while (argi &lt; args.length) &#123; Path file = Paths.get(args[argi]); Files.walkFileTree(file, opts, maxDepth, vistor); argi++; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300import java.nio.file.*;import static java.nio.file.StandardCopyOption.*;import java.nio.file.attribute.*;import static java.nio.file.FileVisitResult.*;import java.io.IOException;import java.util.*;public class Copy &#123; static boolean okayToOverWrite(Path file) &#123; String answer = System.console().readLine(\"overwrite %s (yes/no)?\", file); return (answer.equalsIgnoreCase(\"y\") || answer.equalsIgnoreCase(\"yes\")); &#125; static void copyFile(Path source, Path target, boolean prompt, boolean preserve) &#123; CopyOption[] options = (preserve) ? new CopyOption[] &#123;COPY_ATTRIBUTES, REPLACE_EXISITING&#125; : new CopyOption[] &#123;REPLACE_EXISITING&#125;; if (!prompt || Files.notExists(target) !! okayToOverWrite(target)) &#123; try &#123; Files.copy(source, target, options); &#125; catch (IOException e) &#123; System.err.format(\"Unable to copy: %s: %s%n\", source, e); &#125; &#125; &#125; static class TreeCopier implements FileVisitor&lt;Path&gt; &#123; private final Path source; private final Path target; private final boolean prompt; private final boolean preserve; TreeCopier(Path source, Path target, boolean prompt, boolean preserve) &#123; this.source = source; this.target = target; this.prompt = prompt; this.preserve = preserve; &#125; @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) &#123; CopyOption[] options = (preserve) ? new CopyOption[] &#123;COPY_ATTRIBUTES&#125; : new CopyOption[0]; Path newDir = target.resolve(source.relativize(dir)); try &#123; Files.copy(dir, newDir, options); &#125; catch (FileAlreadyExistsException e) &#123; &#125; catch (IOException e) &#123; System.err.format(\"Unable to create: %s: %s%n\", newDir, e); return SKIP_SUBTREE; &#125; return CONTINUE; &#125; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) &#123; copyFile(file, target.resolve(source.relativize(file)), prompt, preserve); return CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) &#123; if (exc == null &amp;&amp; preserve) &#123; Path newDir = target.resolve(source.relativize(dir)); try &#123; FileTime time = Files.getLastModifiedTime(dir); Files.setLastModifiedTime(newDir, time); &#125; catch (IOException e) &#123; System.err.format(\"Unable to copy all attributes to :%s: %s%n\", newDir, e); &#125; &#125; return CONTINUE; &#125; @Override public FileVisitResult visitFileFailed(Path file, IOException exc) &#123; if (exc instance of FileSystemLoopException) &#123; System.err.println(\"cycle detected: \" + file); &#125; else &#123; System.err.format(\"Unable to copy: %s: %s%n\", file, exc); &#125; return CONTINUE; &#125; &#125; static void usage() &#123; System.err.println(\"java Copy [-ip] source... target\"); System.err.println(\"java Copy -r [-ip] source-dir... target\"); System.exit(-1); &#125; public static void main(String[] args) throws IOException &#123; boolean recursive = false; boolean prompt = false; boolean preserve = false; int argi = 0; while (argi &lt; args.length) &#123; String arg = args[argi]; if (arg.startWith(\"-\")) break; if (arg.length() &lt; 2) usage(); for (int i = 1; i &lt; arg.length(); i++) &#123; char c = arg.charAt(i); switch (c) &#123; case 'r' : recursive = true; break; case 'i' : prompt = true; break; case 'p' : preserve = true; break; default: usage(); &#125; &#125; argi++; &#125; int remaining = args.length - argi; if (remaining &lt; 2) usage(); Path[] source = new Path[remaining-1]; int i = 0; while (remaining &gt; 1) &#123; source[i++] = Paths.get(args[argi++]); remaining--; &#125; Path target = Paths.get(args[argi]); boolean isDir = Files.isDirectory(target); for (i = 0; i &lt; source.length; i++) &#123; Path dest = (isDir) ? target.resolve(source[i].getFileName()) : target; if (recursive) &#123; EnumSet&lt;FileVisitOption&gt; opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS); TreeCopier tc = new TreeCopier(source[i], desct, prompt, preserve); Files.walkFileTree(source[i], opts, Integer.MAX_VALUE, tc); &#125; else &#123; if (Files.isDirectory(source[i])) &#123; System.err.format(\"%s: is a directory%n\", source[i]); continue; &#125; copyFile(source[i], dest, prompt, preserve); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268import java.nio.file.*;import static java.nio.file.StandardWatchEventKinds.*;import static java.nio.file.LinkOption.*;import java.nio.file.attribute.*;import java.io.*;import java.util.*;public class WatchDir &#123; private final WatchService watcher; private final Map&lt;WatchKey, Path&gt; keys; private final boolean recursive; private boolean trace = false; @SuppressWarnings(\"unchecked\") static &lt;T&gt; WatchEvent&lt;T&gt; cast(WatchEvent&lt;?&gt; event) &#123; return (WatchEvent&lt;T&gt;) event; &#125; private void register(Path dir) throws IOException &#123; WatchKey key = dir.register(watcher, ENTRYP_CREATE, ENTRY_DELETE, ENTRY_MODIFY); if (trace) &#123; Path prev = keys.get(key); if (prev == null) &#123; System.out.format(\"register: %s%n\", dir); &#125; else &#123; if (!dir.equals(prev)) &#123; System.out.format(\"update: %s -&gt; %s%n\", prev, dir); &#125; &#125; keys.put(key, dir); &#125; &#125; private void registAll(final Path start) throws IOException &#123; Files.walkFileTree(start, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123; register(dir); return FileVisitResult.CONTINUE; &#125; &#125;); &#125; WatchDir(Path dir, boolean recursive) throws IOException &#123; this.watcher = FileSystems.getDefault().newWatchService(); this.keys = new HashMap&lt;WatchKey, Path&gt;(); this.recursive = recursive; if (recursive) &#123; System.out.format(\"Scanning %s ...%n\", dir); registerAll(dir); System.out.println(\"Done\"); &#125; else &#123; register(dir); &#125; this.trace = true; &#125; void processEvents() &#123; for (; ; ) &#123; WatchKey key; try &#123; key = watcher.take(); &#125; catch (InterruptedException e) &#123; return; &#125; Path dir = keys.get(key); if (dir == null) &#123; System.err.println(\"WatchKey not recognized!!\"); continue; &#125; for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; WatchEvent.Kind kind = event.kind(); // TBD - provide example of how OVERFLOW event is handled. if (kind == OVERFLOW) &#123; continue; &#125; WatchEvent&lt;Path&gt; ev = cast(event); Path name = ev.context(); Path child = dir.resolve(name); System.out.format(\"%s: %s%n\", event.kind().name(), child); if (recursive &amp;&amp; (kind == ENTRYP_CREATE)) &#123; try &#123; if (Files.isDirectory(child, NOFOLLOW_LINKS)) &#123; registerAll(child); &#125; &#125; catch (IOException e) &#123; &#125; &#125; &#125; // reset key and remove from set if directory no longer accessible. boolean valid = key.reset(); if (!valid) &#123; keys.remove(key); if (keys.isEmpty()) &#123; break; &#125; &#125; &#125; &#125; static void usage() &#123; System.err.println(\"usage: java WatchDir [-r] dir\"); System.exit(-1); &#125; public static void main(String[] args) throws IOException &#123; if (args.length == 0 || args.length &gt; 2) &#123; usage(); &#125; boolean recursive = false; int dirArg = 0; if (args[0].equals(\"-r\")) &#123; if (args.length &lt; 2) usage(); recursive = true; dirArg++; &#125; Path dir = Paths.get(args[dirArg]); new WatchDir(dir, recursive).processEvents(); &#125;&#125;","excerpt":"Basic I/OI/O StreamsByte StreamsPrograms use byte streams to perform input and output of 8-bit bytes. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class CopyBytes &#123; public static void main(String[] args) &#123; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream(\"xanadu.txt\"); out = new FileOutputStream(\"outagain.txt\"); int c; while ((c = in.read()) ! = -1) &#123; out.write(c); &#125; &#125; finally &#123; if (in != null) &#123; in.close(); &#125; if (out != null) &#123; out.close(); &#125; &#125; &#125;&#125; Byte streams should only be used for the most primitive I/O. All other stream types are built on byte streams.","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java Concurrency","date":"2017-10-13T06:20:37.000Z","path":"2017/10/13/Java-Concurrency/","text":"Java ConcurrencyProcesses and ThreadsA process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space. Processes are often seen as synonymous with programs or applications. However, what the user sees as a single application may in fact be a set of cooperating process. To faciliate communication between processes, most operating systems support Inter Process Communication(IPC) resources, such as pipes and sockets. Threads are sometimes called lightweight process. Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process. Threads exist within a process - every process has at least one. Threads share the process’s resources, including memory an open files. Defining and Starting a Thread Provide a Runnable object 123456789101112131415161718public class HelloRunnable implements Runnable &#123; public void run() &#123; // doing some work &#125; public static void public static void main(String[] args) &#123; (new Thread(new HelloRunnable())).start(); &#125;&#125; Subclass Thread 123456789101112131415161718public class HelloThread extends Thread &#123; public void run() &#123; // doing some work &#125; public static void public static void main(String[] args) &#123; (new HelloThread()).start(); &#125;&#125; Supporting InterruptionMany methods that throw InterruptedException, such as sleep. If a thread goes a long time without invoking a method that throws InterruptedException, it must periodically invoke Thread.interrupted, which returns true if an interrupt has been received. 12345678910if (Thread.interrupted()) &#123; // throw InterruptedException throw new InterruptedException(); // or doing something&#125; The Interrupt Status Flag. Invoking Thread.interrupt sets this flag. Invoking Thread.interrupted, interrutp status is cleared. The non-static isInterrupted method, which is used by one thread to qurey the interrupt status of another, does not change the interrupt status flag. JoinsThe join method allows one thread to wait for the completion of another. happens-beforeA happens-before relationship is a guarantee that memory written to by statement A is visible to statement B, that is, that statement A completes its write before statement B starts its read. Synchronized methods First, it is not possible for two invocations of Synchronized methods on the same object to interleave. Second, when a Synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. Intrinsic Locks and SynchronizationIntrinsic locks play a role in both aspects of Synchronization: enforcing exclusive access to an object’s state and establishing happens-before relationship that are essential to visibility. Synchronized statements must specify the object that provides the intrinsic lock: 1234567891011121314public void addName(String name) &#123; synchronized(this) &#123; lastName = name; nameCount++; &#125; nameList.add(name);&#125; Synchronized statements are also useful for improving concurrency with fine-grained synchronization. 123456789101112131415161718192021222324252627282930313233343536public class MsLunch &#123; private long c1 = 0; private long c2 = 0; private Object lock1 = new Object(); private Object lock2 = new Object(); public void inc1() &#123; synchronized(lock1) &#123; c1++; &#125; &#125; public void inc2() &#123; synchronized(lock2) &#123; c2++; &#125; &#125;&#125; Atomic access Reads and writes are atomic for reference variables and for most primitive variables(all types except long and double) Reads and writes are atomic for all variables declared volatile(including long and double variables). Using volatile variables reduces the risk of memory consistency errors. When a thread reads a volatile variable, it sees not just the latest change to the volatile, but also the side effects of the code that led up the change. Guarded BlocksThreads often have to coordinate their actions. The most common coordinate idiom is the guarded block. Such a block begins by polling a condition that must be true before the block can proceed. 1234567891011121314public synchronized void guardedJoy() &#123; while (!joy) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125;&#125; Why is this version of guardedJoy synchronized? Suppose d is the object we’re Using to invoke wait. When a thread invokes d.wait, it must own the intrinsic lock for d —— otherwise an error is thrown. Invoking wait inside a synchronized method is a simple way to acquire the intrinsic lock. When wait is invoked, the thread releases the lock and suspends execution. At some future time, another thread will acquire the same lock and invoke Object.notifyAll, informing all threads waiting on that lock that something important has happened. 12345678public synchronized notifyJoy() &#123; joy = true; notifyAll();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//Producer-Consumerpublic class Drop &#123; private String message; private boolean empty = true; public synchronized String take() &#123; while (empty) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; empty = true; notifyAll(); return message; &#125; public synchronized void put(String message) &#123; while (!empty) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; &#125; empty = false; this.message = message; notifyAll(); &#125;&#125;//producerimport java.util.Random;public class Producer implement Runnable &#123; private Drop drop; public Producer(Drop drop) &#123; this.drop = drop; &#125; public void run() &#123; String importantInfo[] = &#123; \"Mares eat oats\", \"Does eat oats\", \"Little lambs eat ivy\", \"A kid will eat ivy too\" &#125;; Random random = new Random(); for (int i = 0; i &lt; importantInfo.length; i++) &#123; drop.put(importantInfo[i]) try &#123; Thread.sleep(random.nextInt(5000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; drop.put(\"DONE\"); &#125;&#125;//Consumerimport java.util.Random;public class Consumer implements Runnable &#123; private Drop drop; public Consumer(Drop drop) &#123; this.drop = drop; &#125; public void run() &#123; Random random = new Random(); for (String message = drop.take(); !message.equals(\"DONE\"); message = drop.take()) &#123; System.out.format(\"MESSAGE RECEIVED: %s%n\", message); try &#123; Thread.sleep(random.nextInt(5000)); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125;public class ProducerConsumerExample &#123; public static void main(String[] args) &#123; Drop drop = new Drop(); (new Thread(new Producer(drop))).start(); (new Thread(new Consumer(drop))).start(); &#125;&#125; Immutable ObjectsA Strategy for Defining Immutable Objects Don’t provide “setter” methods Make all fields final and private Don’t allow subclass to override methods. The simplest way to do this is declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods. If the instance fields reference to mutable objects, don’t allow those objects to be changed: Don’t provide methods that modify the mutable objects. Don’t share references to the mutable objects. High Level concurrencyLock ObjectsThe biggest advantage of Lock objects over implicit locks is their ability to back out of an attempt to acquire a lock. The tryLock method backs out if the lock is not available immediately or before a timeout expires (if specified). The lockInterruptibly method backs out if another thread sends an interrupt before the lock is acquired. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.Random;public class Safelock &#123; static class Friend &#123; private final String name; private final Lock lock = new ReentrantLock(); public Friend(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public boolean impendingBow(Friend bower) &#123; Boolean myLock = false; Boolean yourLock = false; try &#123; myLock = lock.tryLock(); yourLock = bower.lock.tryLock(); &#125; finally &#123; if (! (myLock &amp;&amp; yourLock)) &#123; if (myLock) &#123; lock.unlock(); &#125; if (yourLock) &#123; bower.lock.unlock(); &#125; &#125; &#125; return myLock &amp;&amp; yourLock; &#125; public void bow(Friend bower) &#123; if (impendingBow(bower)) &#123; try &#123; System.out.format(\"%s: %s has bowed to me!%n\", this.name, bower.getName()); bower.bowBack(this); &#125; finally &#123; lock.unlock(); bower.lock.unlock(); &#125; &#125; else &#123; System.out.format(\"%s: %s started to bow to me, but saw that I was already bowing to him.%n\", this.name, bower.getName()); &#125; &#125; public void bowBack(Friend bower) &#123; System.out.format(\"%s: %s has bowed back to me!%n\", this.name, bower.getName()); &#125; &#125; static class BowLoop implements Runnable &#123; private Friend bower; private Friend bowee; public BowLoop(Friend bower, Friend bowee) &#123; this.bower = bower; this.bowee = bowee; &#125; public void run() &#123; Random random = new Random(); for (; ; ) &#123; try &#123; Thread.sleep(random.nextInt(10)); &#125; catch (InterruptedException e) &#123; &#125; bowee.bow(bower); &#125; &#125; &#125; public static void main(String[] args) &#123; final Friend alphonse = new Friend(\"Alphonse\"); final Friend gaston = new Friend(\"Gaston\"); new Thread(new BowLoop(alphonse, gaston)).start(); new Thread(new BowLoop(gaston, alphonse)).start(); &#125;&#125; ExecutorsExecutor Interfaces java.util.concurrent Executor, a simple interface that supports launching new tasks. ExecutorService, a subinterface of Executor, which adds features that help manage the lifecycle, both of the individual tasks and of the executor itself. ScheduleExecutorService, a subinterface of ExecutorService, supports future and/or periodic execution of tasks. Thread Pools java.util.concurrent.Executors newFixedThreadPool newCachedThreadPool newSingleThreadExecutor Several factory methods are ScheduleExecutorService versions of the above executors. Concurrent Collections BlockingQueue ConcurrentMap ConcurrentHashMap ConcurrentNavigableMap ConcurrentSkipListMap Atomic VariablesThe java.util.concurrent.atomic package defines classes that support atomic operations on single variables.","excerpt":"Java ConcurrencyProcesses and ThreadsA process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space. Processes are often seen as synonymous with programs or applications. However, what the user sees as a single application may in fact be a set of cooperating process. To faciliate communication between processes, most operating systems support Inter Process Communication(IPC) resources, such as pipes and sockets. Threads are sometimes called lightweight process. Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process. Threads exist within a process - every process has at least one. Threads share the process’s resources, including memory an open files.","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Debug Spark","date":"2017-10-13T03:35:21.000Z","path":"2017/10/13/Debug-Spark/","text":"Remote Debug Spark Application In Local ModelCreate Remote Debug Configuration In Idea Run &gt;&gt; Edit Configurations &gt;&gt; Remote &gt;&gt; Setting &gt;&gt; Debug mode: Attach &gt;&gt; Modify Host and Port Set System EnvironmentDebug in Local Modeexport SPARK_SUBMIT_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=wolflying:5005wolflying same as the Idea remote debug Host, 5005 same as the Idea remote debug Port. Debug in Standalone Mode debug driver./bin/spark-submit –class org.apache.spark.examples.JavaWordCount –master spark://wolflying:6066 –deploy-mode cluster -v –conf spark.rpc.askTimeout=600s –conf spark.driver.extraJavaOptions=”-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=wolflying:5005” examples/target/original-spark-examples_2.11-2.1.1.jar file:///home/wolflying/Documents/docs/index.html–conf spark.driver.extraJavaOptions=”-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=wolflying:5005” debug executor./bin/spark-submit –class org.apache.spark.examples.JavaWordCount –master spark://wolflying:6066 –deploy-mode cluster -v –conf spark.rpc.askTimeout=600s –conf spark.executor.extraJavaOptions=”-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=wolflying:5005” examples/target/original-spark-examples_2.11-2.1.1.jar file:///home/wolflying/Documents/docs/index.html–conf spark.executor.extraJavaOptions=”-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=wolflying:5005” Submit Spark Job./bin/spark-submit –class org.apache.spark.examples.JavaWordCount –master local examples/target/original-spark-examples_2.11-2.1.1.jar file:///home/wolflying/Documents/docs/index.html OthersBuild Spark Using Maven./build/mvn package./build/mvn -Dscala-2.1.1 -Pyarn -Phadoop-2.7 -Dhadoop.version=2.7.3 -Phive -Phive-thriftserver -DskipTests clean package Build Spark Using Sbt./build/sbt package./build/sbt -Dscala-2.1.1 -Pyarn -Phadoop-2.7 -Dhadoop.version=2.7.3 -Phive -Phive-thriftserver -DskipTests clean package spark official build docsspark debug environment deployment","excerpt":"","tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"}]},{"title":"How Spark run an application","date":"2017-10-13T03:35:13.000Z","path":"2017/10/13/How-Spark-run-an-application/","text":"Standalone Cluster Mode Submitting application to cluster SparkSubmitArguments -&gt; Parses and encapsulates(封装) arguments from the spark-submit script. prepareSubmitEnvironment -&gt; Prepare the environment for submitting an application. childMainClass: org.apache.spark.deploy.rest.RestSubmissionClient. invoke childMainClass.main RestSubmissionClient.constructSubmitRequest -&gt; Construct a message that captures the specified parameters for submitting an application. RestSubmissionClient.createSubmission -&gt; Submit an application specified by the parameters in the provided request. Receive and Process the Submitting Application Request (REST API) StandaloneSubmitRequestServlet.handleSubmit -&gt; Handle the submit request and construct an appropriate response to return to the client. StandaloneSubmitRequestServlet.buildDriverDescription -&gt; Build a driver description from the fields specified in the submit request. DeployMessages.RequestSubmitDriver -&gt; send RequestSubmitDriver message to Spark Master Master.receiveAndReply -&gt; process received message Master.createDriver -&gt; create DriverInfo object Master.schedule -&gt; Schedule the currently available resources among waiting apps. Master.launchDriver -&gt; Send LaunchDriver message to Worker Worker new DriverRunner -&gt; Worker received the LaunchDriver message and create a DriverRunner object. DriverRunner: Manages the execution of one driver. DriverRunner.runDriver -&gt; Launch Driver Command DriverWrapper.main -&gt; launching driver programs(Standalone cluster mode only) invoke Application main method SparkSession.getOrCreate -&gt; get an existing SparkSession or creates a new one. process application. Someting important when Create a SparkContext (Standalone Cluster Mode)SparkContext try catch block SparkContext.createTaskScheduler -&gt; Create a task schedule based on a given master URL. new TaskSchedulerImp -&gt; new StandaloneSchedulerBackend -&gt; A SchedulerBackend implementation for Spark’s standalone cluster manager. new DAGScheduler -&gt; Create a DAG scheduler _taskScheduler.start -&gt; start TaskScheduler after taskScheduler sets DAGScheduler reference in DAGScheduler’s constructor. new ApplicationDescription new StandaloneAppClient -&gt; Interface allowing applications to speak with a Spark standalone cluster manager. StandaloneAppClient.start -&gt; Just launch an AppClient rpcEndpoint Someting important when process ActionsRDD actions run jobs using runJob method. runJob method run a function on a given set of partitions in an RDD and pass the results to the given handler function. getCallsite -&gt; capture the current user callsite and return a formatted version for printing. clean -&gt; Clean a closure to make it ready to serialized and sent to tasks (removes unreferenced in outer’s, updates REPL variables) dagScheduler.runJob -&gt; Run an action job on the given RDD and pass all the results to the resultHandler function as they arrive. DAGScheduler runJob method DAGScheduler.submitJob -&gt; submit an action job to scheduler. post JobSubmitted event -&gt; Types of events that can be handled by the DAGScheduler. DAGScheduler.handleJobSubmitted -&gt; process JobSubmitted event. DAGScheduler.createResultStage -&gt; Create a ResultStage associated with the provided jobID. DAGScheduler.getOrCreateParentStages -&gt; Get or create the list of parent stages for a given RDD. DAGScheduler.getShuffleDependencies -&gt; Returns shuffle dependencies that are immediate parents of the given RDD. DAGScheduler.getOrCreateShuffleMapStage -&gt; Gets a shuffle map stage if one exists in shuffleIdToMapStage. Otherwise, if the shuffle map stage doesn’t already exists, this method will create the shuffle map stage in addition to any missing ancestor shuffler map stages. new ResultStage -&gt; ResultStage apply a function on some partitions of an RDD to compute the result of an action. new ActiveJob -&gt; A running job in the DAGScheduler. DAGScheduler.submitStage -&gt; Submits stage, but first recursively submits any missing parents. DAGScheduler.submitMissingTask -&gt; Called when stage’s parents are available and we can now do its task. OutputCommmitCoordinator.stageStart -&gt; Called by the DAGScheduler when a stage starts. Stage.makeNewStageAttempt -&gt; Creates a new attempt for this stage by creating a new StageInfo with a new attempt ID. SparkContext.broadcast -&gt; Broadcasted binary for the task, used to dispatch tasks to executors. new ShuffleMapTask/ResultTask -&gt; create Task object. TaskSchedulerImp.submitTasks -&gt; TaskSchedulerImp.createTaskSetManager -&gt; Create a TaskSetManager. Schedules the tasks within a single TaskSet. CoarseGrainedSchedulerBackend(SchedulerBackend).reviveOffers driverEndpoint send ReviveOffers message CoarseGrainedSchedulerBackend.makeOffers -&gt; Make fake resource offers on all executors. TaskSchedulerImp.resourceOffers -&gt; Called by cluster manager to offer resources on slaves. CoarseGrainedSchedulerBackend.launchTasks -&gt; Launch tasks returned by a set of resource offers. executorEndpoint send LaunchTask message Executor.launchTask new TaskRunner -&gt; TaskRunner extends Runnable interface. This create a new thread, add it to Executor worker thread pool TaskRunner.run prepare TaskContext of the Task ShuffleMapTask/ResultTask.runTask","excerpt":"Standalone Cluster Mode Submitting application to cluster SparkSubmitArguments -&gt; Parses and encapsulates(封装) arguments from the spark-submit script. prepareSubmitEnvironment -&gt; Prepare the environment for submitting an application. childMainClass: org.apache.spark.deploy.rest.RestSubmissionClient. invoke childMainClass.main RestSubmissionClient.constructSubmitRequest -&gt; Construct a message that captures the specified parameters for submitting an application. RestSubmissionClient.createSubmission -&gt; Submit an application specified by the parameters in the provided request. Receive and Process the Submitting Application Request (REST API) StandaloneSubmitRequestServlet.handleSubmit -&gt; Handle the submit request and construct an appropriate response to return to the client. StandaloneSubmitRequestServlet.buildDriverDescription -&gt; Build a driver description from the fields specified in the submit request. DeployMessages.RequestSubmitDriver -&gt; send RequestSubmitDriver message to Spark Master Master.receiveAndReply -&gt; process received message Master.createDriver -&gt; create DriverInfo object Master.schedule -&gt; Schedule the currently available resources among waiting apps. Master.launchDriver -&gt; Send LaunchDriver message to Worker Worker new DriverRunner -&gt; Worker received the LaunchDriver message and create a DriverRunner object. DriverRunner: Manages the execution of one driver. DriverRunner.runDriver -&gt; Launch Driver Command DriverWrapper.main -&gt; launching driver programs(Standalone cluster mode only) invoke Application main method SparkSession.getOrCreate -&gt; get an existing SparkSession or creates a new one. process application.","tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"}]}]